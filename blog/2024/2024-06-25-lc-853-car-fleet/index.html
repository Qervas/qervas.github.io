<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <h3 id="problem-overview">Problem Overview</h3> <p>The problem requires determining how many car fleets will arrive at a destination given the starting positions and speeds of the cars. A car fleet is a group of cars that travel together at the same speed due to the leading car.</p> <h3 id="initial-analysis">Initial Analysis</h3> <p>Initially, I considered using a hash table to manage the positions and speeds of the cars. Here’s how I thought it might work:</p> <ul> <li> <strong>Buckets for Positions</strong>: Using an unordered_map, each car’s position would be a key, and the speed would be the value.</li> <li> <strong>Collision Detection</strong>: At each time tick, update the car positions. If two cars share a position, merge them into a fleet and adjust the speed.</li> <li> <strong>Complexity Concerns</strong>: Continuously updating positions and merging fleets seemed computationally expensive, especially with large inputs.</li> </ul> <p>While the hash table approach appeared promising due to its average O(1) complexity for insertions and lookups, the dynamic nature of updating positions and merging fleets introduced high overhead. This realization led me to explore more efficient solutions.</p> <h3 id="transition-to-a-stack-based-approach">Transition to a Stack-Based Approach</h3> <p>Recognizing the potential inefficiencies of the hash table method, I shifted to a more straightforward and efficient stack-based approach. This method leverages sorting and a single pass through the list of cars to manage fleets.</p> <h3 id="detailed-solution">Detailed Solution</h3> <ol> <li> <p><strong>Calculate Time to Target</strong>: For each car, compute the time it will take to reach the target using:</p> \[\text{time} = \frac{\text{target} - \text{position[i]}}{\text{speed[i]}}\] </li> <li> <strong>Sort Cars by Position</strong>: Sort the cars based on their starting positions in descending order. This allows us to process the farthest car first.</li> <li> <p><strong>Use a Stack to Track Fleets</strong>:</p> <ul> <li>Initialize a stack to keep track of the maximum time of the current fleet to reach the target.</li> <li>Iterate through the sorted list of cars: <ul> <li>If a car’s time to target is greater than the current maximum (top of the stack), it forms a new fleet.</li> <li>If a car can catch up to the fleet in front, it joins that fleet.</li> </ul> </li> </ul> </li> </ol> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//to be noticed, time is a real number not an integer</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">carFleet</span><span class="p">(</span><span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">position</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">speed</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">"These 2 containers should be the same size."</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span><span class="k">return</span> <span class="mi">1</span><span class="p">;}</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">time</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">time</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">time</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">speed</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="n">comparator</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">position</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="p">};</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">indices</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
        <span class="n">iota</span><span class="p">(</span><span class="n">indices</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">indices</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">indices</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">indices</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">comparator</span><span class="p">);</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&gt;</span> <span class="n">cars</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">position</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">cars</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">position</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]);</span>
            <span class="n">cars</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>  
        <span class="p">}</span>
  
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">stack</span><span class="p">{};</span>
        <span class="n">stack</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cars</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cars</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">cars</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">stack</span><span class="p">.</span><span class="n">back</span><span class="p">()){</span>
                <span class="n">stack</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cars</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>  

        <span class="k">return</span> <span class="n">stack</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="conclusion">Conclusion</h3> <p>This approach effectively reduces complexity by leveraging sorting and a stack to manage the fleets. The result is an efficient algorithm with a time complexity of $O(n log n)$ due to sorting and $O(n)$ for the single pass through the cars.</p> <p>The process of transitioning from the hash table idea to the stack-based solution was a valuable learning experience. It underscored the importance of evaluating algorithm efficiency and adapting strategies to optimize performance.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/date/Jun_25_2024/car_fleet-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/date/Jun_25_2024/car_fleet-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/date/Jun_25_2024/car_fleet-1400.webp"></source> <img src="/assets/img/date/Jun_25_2024/car_fleet.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> </body></html>